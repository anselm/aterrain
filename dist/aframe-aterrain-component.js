/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/all.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/ImageServer.js":
/*!****************************!*\
  !*** ./src/ImageServer.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n\n///\n/// BingImageProvider - fetch tiles directly from Bing on demand as threejs materials\n///\n/// TODO - caches images but never flushes them - should flush old images\n/// TODO - the key is hardcoded - should be supplied by caller\n///\n\nclass BingImageProvider {\n\n  constructor() {\n    this.cached = {};\n  }\n\n  readyPromise(resolve) {\n    let scope = this;\n    if(scope.imageurl) {\n      resolve();\n      return;\n    }\n    let metadata = \"https://dev.virtualearth.net/REST/V1/Imagery/Metadata/Aerial?output=json&include=ImageryProviders&key=RsYNpiMKfN7KuwZrt8ur~ylV3-qaXdDWiVc2F5NCoFA~AkXwps2-UcRkk2L60K5qBy5kPnTmwvxdfwl532NTheLdFfvYlVJbLnNWG1iC-RGL\";\n    fetch(metadata).then(response => { return response.json() }).then( json => {\n      if(!json.resourceSets.length || !json.resourceSets[0].resources.length) {\n        console.error(\"Too many requests\");\n        setTimeout(function() { resolve(); },Math.random() * 10 + 1);\n      } else {\n        let subdomains = json.resourceSets[0].resources[0].imageUrlSubdomains;\n        scope.subdomain = subdomains[~~(subdomains.length * Math.random())];\n        scope.imageurl = json.resourceSets[0].resources[0].imageUrl;\n        scope.imageurl = scope.imageurl.replace(\"http\", \"https\");\n        scope.imageurl = scope.imageurl.replace(\"{culture}\", \"en-US\");\n        scope.imageurl = scope.imageurl.replace(\"{subdomain}\",scope.subdomain);\n        scope.imageurl = scope.imageurl.replace(\"jpeg\", \"png\");\n        resolve();\n      }\n    });\n  }\n\n  quadkey(x, y, z) {\n    let quadKey = [];\n    for (var i = z; i > 0; i--) {\n      var digit = '0';\n      var mask = 1 << (i - 1);\n      if ((x & mask) != 0) {\n          digit++;\n      }\n      if ((y & mask) != 0) {\n          digit++;\n          digit++;\n      }\n      quadKey.push(digit);\n    }\n    return quadKey.join('');\n  }\n\n  requestImage(x,y,lod) {\n    let scope = this;\n\n    let key = x + \"-\" + y + \"-\" + lod;\n    let c = scope.cached[key];\n    if(c) {\n      return new Promise(function(resolve,reject) {\n        resolve(c);\n      });\n    }\n\n    return new Promise(function(resolve,reject) {\n      let quadkey = scope.quadkey(x,y,lod);\n      let url = scope.imageurl.replace(\"{quadkey}\", quadkey);\n      let image = new Image();\n      image.onload = unused => {\n        scope.cached[key] = image;\n        resolve(image);\n      }\n      fetch(url).then(response => { return response.blob(); }).then( blob => {\n        image.url = url;\n        image.src = URL.createObjectURL(blob);\n      });\n    });\n  }\n}\n\n///\n/// ImageServer returns images on demand that match the terrain tile boundaries.\n///\n/// TODO Cesium access token should be settable\n/// TODO Code is over-specialized around Bing Images + Cesium Elevation Tiles - but hard to generalize trivially.\n///\n\nclass ImageServer {\n\n  constructor() {\n    this.data = {};\n    this.data.debug = false;\n    //this.data.mapStyle = Cesium.BingMapsStyle.AERIAL;\n    this.data.source = 0;\n    if(this.data.source == 0) {\n      // bypass cesium\n      this.imageProvider = new BingImageProvider();\n    } else if(this.data.source == 1) {\n       // cesium for sf area - Something seems to be not working with this provider although it's the one I'd prefer to use right now - mar 1 2018\n       this.data.CesiumionAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiJlYmI0ZmY0My1hOTg5LTQzNWEtYWRjNy1kYzYzNTM5ZjYyZDciLCJpZCI6NjksImFzc2V0cyI6WzM3MDQsMzcwMywzNjk5LDM2OTNdLCJpYXQiOjE1MTY4MzA4ODZ9.kM-JnlG-00e7S_9fqS_QpXYTg7y5-cIEcZEgxKwRt5E';\n       this.data.url = 'https://beta.cesium.com/api/assets/3693?access_token=' + this.data.CesiumionAccessToken;\n       this.imageProvider = new Cesium.createTileMapServiceImageryProvider(this.data);\n    } else if(this.data.source == 2) {\n      // Cesium Bing abstraction in general - works ok although LOD is off by one?\n      this.data.key = 'RsYNpiMKfN7KuwZrt8ur~ylV3-qaXdDWiVc2F5NCoFA~AkXwps2-UcRkk2L60K5qBy5kPnTmwvxdfwl532NTheLdFfvYlVJbLnNWG1iC-RGL';\n      this.data.url = 'https://dev.virtualearth.net',\n      this.imageProvider = new Cesium.BingMapsImageryProvider(this.data);\n    }\n  }\n\n  isReady() {\n    // TODO examine why do the readypromises differ?\n    if(this.data.source == 0) {\n      return this.imageProvider && this.imageProvider.imageurl;\n    } else {\n      return this.imageProvider && this.imageProvider.ready;\n    }    \n  }\n\n  ready(callback) {\n    // TODO examine why do the readypromises differ?\n    if(this.data.source == 0) {\n      this.imageProvider.readyPromise(callback);\n    } else {\n      Cesium.when(this.imageProvider.readyPromise).then(callback);\n    }\n  }\n\n  // this method calculates the image tile and fractional component (ie which pixel) of the image tile to fetch\n  projection2tile(scheme,image_lod,y) {\n    // which tile in the y axis - and retain fractional pixel pos\n    let lat = scheme.rect.north - y*scheme.degrees_latrad/256; // range PI/2 to -PI/2\n    // https://msdn.microsoft.com/en-us/library/bb259689.aspx -> no data past these points (I want max Y to be within the previous tile)\n    if(lat >= 1.48442222975) lat = 1.48442222974;\n    if(lat <= -1.48442222975) lat = -1.48442222974;\n    let sinLat = Math.sin(lat);\n    let tileY = (0.5 - Math.log((1 + sinLat) / (1 - sinLat)) / (4 * Math.PI)) * image_lod;\n    return tileY;\n  }\n\n  provideImageProjected(scheme,callback) {\n\n    // For Mercator, check out Slide 39-43 of Rendering the Whole Wide World on the World Wide Web for some background and reprojectToGeographic() in ImageryLayer.js for how Cesium currently does it.\n    // Here the reprojection is done on CPU...\n\n    // circument a quirk with cesium data source\n    let uselod = (this.data.source == 2) ? scheme.lod+1 : scheme.lod+1;\n\n    // get image tiles at one level deeper than terrain tiles to take advantage of x lining up\n    let image_lod = Math.pow(2,uselod);\n\n    // where is the top and bottom tile?\n    let ty1 = this.projection2tile(scheme,image_lod,0,0);\n    let ty2 = this.projection2tile(scheme,image_lod,255,255);\n    let tx1 = scheme.xtile;\n\n    // load entire range of tiles\n    let promises = [];\n    for(let i = Math.floor(ty1);i<=Math.floor(ty2);i++) {\n      let p = this.imageProvider.requestImage(tx1,i,scheme.lod+1);\n      promises.push(p);\n    }\n\n    // get canvas to paint to for final output\n    // TODO may as well put this indie the promise\n    let canvas = this.canvas_new();\n\n    // Paint once loaded\n    Promise.all(promises).then(results => {\n\n      // convert the img to something that can be read and written\n      if(!results.length) {\n        console.error(\"Image server no image content error 1\");\n        return;        \n      }\n\n      // a canvas is required per image source in order to get at the pixels\n      for(let i = 0; i < results.length;i++) {        \n        if(typeof results[i] == 'undefined' || !results[i]) {\n          console.error(\"Image server no image content error 2\");\n          return;\n        }\n        this.canvas_from_image(results[i]);\n      }\n\n      // walk the sources and copy pixels to a target - this is labor intensive\n      for(let y = 0;y<256;y++) {\n\n        // get reverse mercator pixel location (only y is needed)\n        let txy = this.projection2tile(scheme,image_lod,y);\n\n        // get that tile (offset from the set of tiles we happen to have)\n        let image = results[Math.floor(txy)-Math.floor(ty1)];\n\n        // get y in tile\n        let yy = Math.floor(txy*256) & 255;\n\n        // copy that row (there is no horizontal reprojection only vertical)\n        // TODO this could be optimized such as by not setting the alpha here and copying uints\n        for(let x = 0; x<256;x++) {\n          canvas.imageData.data[(y*256+x)*4+0] = image.imageData.data[(yy*256+x)*4+0];\n          canvas.imageData.data[(y*256+x)*4+1] = image.imageData.data[(yy*256+x)*4+1];\n          canvas.imageData.data[(y*256+x)*4+2] = image.imageData.data[(yy*256+x)*4+2];\n          canvas.imageData.data[(y*256+x)*4+3] = 255;\n        }\n      }\n\n      // return to the caller\n      callback(this.canvas_to_material_from_imagedata(canvas));\n    });\n  }\n\n  provideImage(scheme,callback) {\n    this.provideImageProjected(scheme,callback);\n  }\n\n  //////////////////////////////////////////////////////////// canvas assistance\n\n  canvas_new() {\n    let canvas = document.createElement('canvas');\n    canvas.id = \"canvas\";\n    canvas.width = 256;\n    canvas.height = 256;\n    canvas.ctx = canvas.getContext(\"2d\");\n    canvas.ctx.fillStyle = \"#ff0000\";\n    canvas.ctx.fillRect(0,0,256,256);\n    canvas.imageData = canvas.ctx.getImageData(0,0,256,256);\n    //  var buf = new ArrayBuffer(imageData.data.length);\n    //  var buf8 = new Uint8ClampedArray(buf);\n    //  var data = new Uint32Array(buf);\n    return canvas;\n  }\n\n  canvas_from_image(image) {\n    if(image.canvas) return;\n    image.canvas = document.createElement('canvas');\n    image.canvas.width = 256;\n    image.canvas.height = 256;\n    image.canvas.ctx = image.canvas.getContext(\"2d\");\n    image.canvas.ctx.fillStyle = \"#ffff00\";\n    image.canvas.ctx.fillRect(0,0,256,256);\n    image.canvas.ctx.drawImage(image,0,0,256,256);\n    image.imageData = image.canvas.ctx.getImageData(0,0,256,256);\n  }\n\n  canvas_to_material(canvas) {\n\n    if(this.data.debug) {\n      let ctx = canvas.ctx;\n      ctx.beginPath();\n      ctx.lineWidth=\"6\";\n      ctx.strokeStyle=\"red\";\n      ctx.rect(0,0,255,255); \n      ctx.stroke();\n    }\n\n    //let material = new THREE.MeshPhongMaterial( { color:0xffffff, wireframe:false });\n    let material = new THREE.MeshLambertMaterial( { color:0xffffff, wireframe:false }); //shading: THREE.SmoothShading});\n    material.map = new THREE.Texture(canvas);\n    material.map.needsUpdate = true;\n    return material;\n  }\n\n  canvas_to_material_from_imagedata(canvas) {\n    // data[y * canvasWidth + x] = 0xff00000+b<<16+g<<8+r;\n    // imageData.data.set(buf8);\n    canvas.ctx.putImageData(canvas.imageData, 0, 0);\n    return this.canvas_to_material(canvas);\n  }\n\n}\n\n///\n/// Singelton convenience handles\n/// TODO an AFrame System could do this https://aframe.io/docs/0.7.0/core/systems.html\n///\n\nImageServer.instance = function() {\n  if(ImageServer.imageServer) return ImageServer.imageServer;\n  ImageServer.imageServer = new ImageServer();\n  return ImageServer.imageServer;\n};\n\n\n// es6 glue\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (ImageServer);\n\n\n\n//# sourceURL=webpack:///./src/ImageServer.js?");

/***/ }),

/***/ "./src/TileServer.js":
/*!***************************!*\
  !*** ./src/TileServer.js ***!
  \***************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _ImageServer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ImageServer.js */ \"./src/ImageServer.js\");\n\n\n\n///\n/// TileServer\n///\n/// Provides a generic interface to height field based tiles.\n/// The philosophy here is that if you want to implement a different data source then you write a separate class.\n/// TODO change this to an aframe-system\n/// TODO ellipsoid is spherical and should be oblate\n\nclass TileServer  {\n\n \n  getGround(lat,lon,lod,url,callback) {\n    // this whole routine is heavy due to needing to initialize cesium - a better approach is to look at loaded tile data - improve later TODO\n \n    this.setProvider(url);\n\n    // TODO replace with custom height derivation - see findClosestElevation() - but it needs to interpolate still\n    Cesium.when(this.terrainProvider.readyPromise).then( () => {\n      let poi = Cesium.Cartographic.fromDegrees(lon,lat);\n      if(lod > 15) lod = 15; // there are no tiles at some higher levels of detail\n      Cesium.sampleTerrain(this.terrainProvider,lod,[poi]).then(function(groundResults) {\n        callback(groundResults[0].height);\n      });\n    });\n  }\n\n  findClosestElevation(scheme) {\n    // TODO may want to actually interpolate rather than merely taking the closest elevation...\n    if(!scheme.tile) return 0;\n    let tile = scheme.tile;\n    let distance = Number.MAX_SAFE_INTEGER;\n    let best = 0;\n    for (let i=0; i<tile._uValues.length; i++) {\n      let x = (scheme.x-scheme.xtile)*32767 - tile._uValues[i]; // compiler will optimize\n      let y = (scheme.y-scheme.ytile)*32767 - tile._vValues[i];\n      if(x*x+y*y < distance) {\n        distance = x*x+y*y;\n        best = (((tile._heightValues[i]*(tile._maximumHeight-tile._minimumHeight))/32767.0)+tile._minimumHeight);\n      }\n    }\n    return best;\n  }\n\n  elevation2lod(world_radius,d) {\n    let c = 2*Math.PI*world_radius;\n    // truncate reasonable estimations for lod where d = distane above planetary surface in planetary units\n    if(d < 1) d = 1;\n    if(d > c/2) d = c/2;\n    // even a small camera fov of 45' would show the entire circumference of the planet at a distance of r*2 if the planet was flattened\n    // the visible area is basically distance * 2 ... so  ... number of tiles = circumference / (distance*2)\n    // visible coverage is 2^(lod+1) = number of tiles  or .... 2^(lod+1) = c / (d*2) ... or ... \n    // also see https://gis.stackexchange.com/questions/12991/how-to-calculate-distance-to-ground-of-all-18-osm-zoom-levels/142555#142555\n    let lod = Math.floor(Math.log2(c/(d*2)));\n    // truncate hard limits for external tile services\n    if(lod < 0) lod = 0;\n    if(lod > 19) lod = 19;\n    return lod;\n  }\n\n  ll2v(latrad,lonrad,r=1) {\n    // given a latitude and longitude in radians return a vector\n    let phi = Math.PI/2-latrad;\n    let theta = Math.PI/2+lonrad;\n    let x = -r*Math.sin(phi)*Math.cos(theta);\n    let z = r*Math.sin(phi)*Math.sin(theta);\n    let y = r*Math.cos(phi);\n    return new THREE.Vector3(x,y,z);\n  }\n\n  scheme_elaborate(data) {\n\n    // If I was doing this correctly:\n    // Ellipsoid : https://github.com/AnalyticalGraphicsInc/cesium/blob/master/Source/Core/Ellipsoid.js#L85\n    // cartographicToCartesian : https://github.com/AnalyticalGraphicsInc/cesium/blob/master/Source/Core/Ellipsoid.js#L386\n\n    // This commented out approach is the more correct way get below details from an arbitrary cesium terrain provider - but requires waiting for ready event\n    // this.terrainProvider.tilingScheme.getNumberOfXTilesAtLevel(lod) * (180+lon) / 360;\n    // this.terrainProvider.tilingScheme.getNumberOfYTilesAtLevel(lod) * ( 90-lat) / 180;\n    // let poi = Cesium.Cartographic.fromDegrees(lon,lat);\n    // let xy = this.terrainProvider.tilingScheme.positionToTileXY(poi,lod);\n    // scheme.rect = this.terrainProvider.tilingScheme.tileXYToRectangle(xy.x,xy.y,lod);\n\n    let scheme = {};\n\n    let lat = scheme.lat = data.lat;\n    let lon = scheme.lon = data.lon;\n    let lod = scheme.lod = data.lod;\n\n    // the rendering radius\n    let radius = scheme.radius = data.radius;\n\n    // the planet radius\n    scheme.world_radius = data.world_radius;\n\n    // stretch\n    scheme.stretch = data.stretch || 1;\n\n    // get number of tiles wide and tall - hardcoded to cesium terrain tiles TMS format\n    scheme.w = Math.pow(2,lod+1);\n    scheme.h = Math.pow(2,lod);\n\n    // get tile index with fractional exact position\n    scheme.x = (180+lon) * scheme.w / 360;\n    scheme.y = ( 90-lat) * scheme.h / 180;\n\n    // get tile index (remove fraction)\n    scheme.xtile = Math.floor(scheme.x);\n    scheme.ytile = Math.floor(scheme.y);\n\n    // calculate uuid for tile\n    // TODO must generate custom schemes for multiple simultaneous globes on the same aframe app\n    scheme.uuid = \"tile-\"+scheme.xtile+\"-\"+scheme.ytile+\"-\"+lod;\n\n    // radian version of non-quantized exact position (will be somewhere inside of the quantized latitude and longitude extent)\n    scheme.lonrad = scheme.lon * Math.PI / 180;\n    scheme.latrad = scheme.lat * Math.PI / 180;\n\n    // exact corners in radians where 0,0 is the equator off of africa\n    let a = -Math.PI   + (scheme.xtile + 0) * Math.PI * 2 / scheme.w;\n    let b = -Math.PI   + (scheme.xtile + 1) * Math.PI * 2 / scheme.w;\n    let c =  Math.PI/2 - (scheme.ytile+0) * Math.PI / scheme.h;\n    let d =  Math.PI/2 - (scheme.ytile+1) * Math.PI / scheme.h;\n    scheme.rect = { west:a, south:d, east:b, north:c };\n\n    // degrees of coverage in radiams\n    scheme.degrees_lonrad = scheme.rect.east-scheme.rect.west;\n    scheme.degrees_latrad = scheme.rect.north-scheme.rect.south;\n\n    // degrees of coverage\n    scheme.degrees_lon = 360 / scheme.w; \n    scheme.degrees_lat = 180 / scheme.h;\n\n    // convenience values\n    scheme.width_world = 2*Math.PI*scheme.world_radius;\n    scheme.width_tile_flat = scheme.width_world / scheme.w;\n    scheme.width_tile_lat = scheme.width_tile_flat * Math.cos(data.lat * Math.PI / 180);\n\n    return scheme;\n  }\n\n  /*\n  toGeometryUnusedTest(scene) {\n\n    // some test code to look at how cesium was building the Gudermannian \n\n    // prepare to build a portion of the hull of the surface of the planet - this will be a curved mesh of x by y resolution (see below)\n    let geometry = new THREE.Geometry();\n\n    // scale is arbitrary\n    let scale = 256;\n\n    // stride across the hull at this x resolution\n    let xs = 16;\n\n    // stride across the hull at this y resolution\n    let ys = 16;\n\n    // here is the code from https://github.com/AnalyticalGraphicsInc/cesium/blob/master/Source/Scene/ImageryLayer.js#L1026\n    // just wanted to see what the fractional values were over some extent\n\n    var sinLatitude = Math.sin(scheme.rect.south);\n    var southMercatorY = 0.5 * Math.log((1 + sinLatitude) / (1 - sinLatitude));\n\n    sinLatitude = Math.sin(scheme.rect.north);\n    var northMercatorY = 0.5 * Math.log((1 + sinLatitude) / (1 - sinLatitude));\n    var oneOverMercatorHeight = 1.0 / (northMercatorY - southMercatorY);\n\n    // build vertices (for a given x,y point on the hull calculate the longitude and latitude of that point)\n    for(let y = 0; y <= scale; y+=ys) {\n     // for(let x = 0; x <= scale; x+=xs) {\n        let fraction = y / 255;\n        let latitude = (scheme.rect.south-scheme.rect.north) * fraction;\n         sinLatitude = Math.sin(latitude);\n        let mercatorY = 0.5 * Math.log((1.0 + sinLatitude) / (1.0 - sinLatitude));\n        let mercatorFraction = (mercatorY - southMercatorY) * oneOverMercatorHeight;\n      //}\n    }\n  }\n  */\n\n  /*\n  toGeometryIdealized(scheme) {\n\n    // OBSOLETE\n\n    // prepare to build a portion of the hull of the surface of the planet - this will be a curved mesh of x by y resolution (see below)\n    let geometry = new THREE.Geometry();\n\n    // scale is arbitrary\n    let scale = 256;\n\n    // stride across the hull at this x resolution\n    let xs = 16;\n\n    // stride across the hull at this y resolution\n    let ys = 16;\n\n    // build vertices (for a given x,y point on the hull calculate the longitude and latitude of that point)\n    for(let y = 0; y <= scale; y+=ys) {\n      for(let x = 0; x <= scale; x+=xs) {\n\n        // x position for vertex within hull\n        let lonrad = scheme.degrees_lonrad * x / scale + scheme.rect.west;\n\n        // y position for vertex within hull\n        let latrad = scheme.rect.north - scheme.degrees_latrad * y / scale;\n\n        //if(this.guder) { latrad = gudermannian_radians(latrad); }\n\n        let radius = scheme.radius;\n        let v = this.ll2v(latrad,lonrad,radius);\n        geometry.vertices.push(v);\n      }\n    }\n    // connect the dots\n    for(let y = 0, v =0; y < scale; y+=ys) {\n      for(let x = 0; x < scale; x+=xs) {\n        geometry.faces.push(new THREE.Face3(v+1,v,v+scale/xs+1));\n        geometry.faces.push(new THREE.Face3(v+1,v+scale/xs+1,v+scale/xs+1+1));\n        v++;\n      }\n      v++;\n    }\n    // uvs\n    geometry.faceVertexUvs[0] = [];\n    for(let y = 0, v = 0; y < scale; y+=ys) {\n      for(let x = 0; x < scale; x+=xs) {\n        let vxa = x/scale;\n        let vya = y/scale;\n        let vxb = (x+xs)/scale;\n        let vyb = (y+ys)/scale;\n        vya = 1-vya;\n        vyb = 1-vyb;\n        geometry.faceVertexUvs[0].push([ new THREE.Vector2(vxb,vya), new THREE.Vector2(vxa,vya), new THREE.Vector2(vxa,vyb) ]);\n        geometry.faceVertexUvs[0].push([ new THREE.Vector2(vxb,vya), new THREE.Vector2(vxa,vyb), new THREE.Vector2(vxb,vyb) ]);\n      }\n    }\n    geometry.uvsNeedUpdate = true;\n    // normals\n    geometry.computeVertexNormals();\n    geometry.computeFaceNormals();\n    return geometry;\n  }\n  */\n\n  toGeometry(scheme) {\n\n    //\n    // see https://github.com/AnalyticalGraphicsInc/quantized-mesh\n    //\n    // note in cesium this is done on GPU - which is not an option sadly due to game collisions and physics - see:\n    //    EncodedCartesian3.js\n    //    translateRelativeToEye.glsl\n\n    let tile = scheme.tile;\n    let radius = scheme.radius;\n    let world_radius = scheme.world_radius;\n    let stretch = scheme.stretch || 1;\n\n    // a slightly laborious way - help rotate vertices in the tile so that they're actually at the equator (at 0,0 lat lon)\n    let angle1 = scheme.rect.south;\n    let angle2 = scheme.rect.west;\n    let axis1 = new THREE.Vector3(1,0,0);\n    let axis2 = new THREE.Vector3(0,1,0);\n\n    // store this here for now (it helps with building height)\n    scheme.average_height = 0;\n\n    // calculate vertices\n    let vertices = [];\n    for (let i=0; i<tile._uValues.length; i++) {\n      // find exact latitude - it's important to consider the offset from the poles due to narrowing there\n      let z = tile._vValues[i]/32767*scheme.degrees_latrad + scheme.rect.south;\n      // find ~latitude - just take a GMT centered straddle so it reduces labor later on because I want this centered at 0,0,0\n      let x = (tile._uValues[i]/32767)*scheme.degrees_lonrad + scheme.rect.west;\n      // get height values in meters from the earths center above sea level (actually SF itself is about 24m below sea level)\n      let y = (((tile._heightValues[i]*(tile._maximumHeight-tile._minimumHeight))/32767.0)+tile._minimumHeight)*stretch;\n\n      // accumulate average height\n      scheme.average_height += y / tile._uValues.length;\n\n      // convert latitude, longitude and height to a position on the earths surface that will be at [ latitude,0 ]\n      // TODO this could take into account the ellipsoid rather than being a perfect sphere\n      let v = this.ll2v(z,x,y+world_radius);\n\n      // scale down  the rendering radius\n      v.x = v.x / world_radius * radius;\n      v.y = v.y / world_radius * radius;\n      v.z = v.z / world_radius * radius;\n\n      // slide the tile horizontally to be centered vertically on GMT - TODO this is computationally sloppy and could be vastly optimized\n      v.applyAxisAngle(axis2,-scheme.rect.west); //- scheme.degrees_lonrad / 2 ); // (used to center but now am leaving at corner)\n\n      // slide the tile vertically to be centered vertically on 0,0 - TODO could be done more cleanly at less cost\n      v.applyAxisAngle(axis1,scheme.rect.south);// + scheme.degrees_latrad / 2 ); // (used to center but now am leaving at corner)\n\n      // in model space - center the vertices so that the entire tile is at the origin 0,0,0 in cartesian coordinates\n      v.z -= radius;\n\n      // save vertex\n      vertices.push(v);\n    }\n\n    // build geometry\n    let geometry = new THREE.Geometry();\n    // build vertices\n    geometry.vertices = vertices;\n    // build faces\n    for (let i=0; i<tile._indices.length-1; i=i+3) {\n      geometry.faces.push(new THREE.Face3(tile._indices[i], tile._indices[i+1], tile._indices[i+2]));\n    }\n    // face vertices to linear distribution uv map\n    let faces = geometry.faces;\n    geometry.faceVertexUvs[0] = [];\n    for (let i = 0; i < faces.length ; i++) {\n      let vxa = tile._uValues[faces[i].a]/32767;\n      let vya = tile._vValues[faces[i].a]/32767;\n      let vxb = tile._uValues[faces[i].b]/32767;\n      let vyb = tile._vValues[faces[i].b]/32767;\n      let vxc = tile._uValues[faces[i].c]/32767;\n      let vyc = tile._vValues[faces[i].c]/32767;\n      geometry.faceVertexUvs[0].push([ new THREE.Vector2(vxa,vya), new THREE.Vector2(vxb,vyb), new THREE.Vector2(vxc,vyc) ]);\n    }\n    // return geometry\n    geometry.uvsNeedUpdate = true;\n    geometry.computeVertexNormals();\n    geometry.computeFaceNormals();\n    geometry.computeBoundingBox();\n    geometry.computeBoundingSphere();\n    return geometry;\n  }\n\n  isReady() {\n    if(!this.terrainProvider || !this.terrainProvider.ready || !_ImageServer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].instance() || !_ImageServer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].instance().isReady()) {\n      return false;\n    }\n    return true;\n  }\n\n  setProvider(url) {\n    if(this.terrainProvider) return;\n    // this.terrainProvider = new Cesium.CesiumTerrainProvider({ ellipsoid:new Cesium.Ellipsoid(1,1,1), requestVertexNormals:true, url:url });\n    this.terrainProvider = Cesium.createWorldTerrain();\n  }\n\n  ready(url,callback) {\n    this.setProvider(url);\n    Cesium.when(this.terrainProvider.readyPromise).then( () => {\n      _ImageServer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].instance().ready( () => {\n        callback();\n      });\n    });\n  }\n\n  produceTile(data,callback) {\n\n    this.setProvider(data.url);\n\n    let material = 0;\n\n    if(data.groundTexture && data.groundTexture.length) {\n      let texture = new THREE.TextureLoader().load(data.groundTexture);\n      material = new THREE.MeshBasicMaterial({map:texture,color:0xffffff});\n    }\n\n    Cesium.when(this.terrainProvider.readyPromise).then( () => {\n      _ImageServer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].instance().ready( () => {\n        let scheme = this.scheme_elaborate(data);\n        if(!material) {\n          this.imageProvider = _ImageServer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].instance(); // not the most elegant... TODO move? have a parent wrapper for both providers?\n          this.imageProvider.provideImage(scheme, material2 => {\n            scheme.material = material2;\n            Cesium.when(this.terrainProvider.requestTileGeometry(scheme.xtile,scheme.ytile,scheme.lod),tile => {\n              scheme.tile = tile;\n              scheme.geometry = this.toGeometry(scheme); // this.toGeometryIdealized(scheme);\n              scheme.mesh = new THREE.Mesh(scheme.geometry,scheme.material);\n              callback(scheme);\n            });\n          });\n        } else {\n            scheme.material = material;\n            Cesium.when(this.terrainProvider.requestTileGeometry(scheme.xtile,scheme.ytile,scheme.lod),tile => {\n              scheme.tile = tile;\n              scheme.geometry = this.toGeometry(scheme); // this.toGeometryIdealized(scheme);\n              scheme.mesh = new THREE.Mesh(scheme.geometry,scheme.material);\n              callback(scheme);\n            });\n        }\n      });\n    });\n  }\n}\n\n///\n/// Singelton convenience handles\n/// TODO an AFrame System could do this https://aframe.io/docs/0.7.0/core/systems.html\n///\n\nTileServer.instance = function() {\n  if(TileServer.tileServer) return TileServer.tileServer;\n  TileServer.tileServer = new TileServer();\n  return TileServer.tileServer;\n};\n\n// es6 glue\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (TileServer);\n\n\n\n//# sourceURL=webpack:///./src/TileServer.js?");

/***/ }),

/***/ "./src/a-building.js":
/*!***************************!*\
  !*** ./src/a-building.js ***!
  \***************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _TileServer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TileServer.js */ \"./src/TileServer.js\");\n\nif (typeof AFRAME === 'undefined') {\n  throw new Error('Component attempted to register before AFRAME was available.');\n}\n\n\n\n///\n/// a-building\n///\n/// wrap cesium 3d tiles and adjust position and size\n///\n/// TODO buildings are still not centered perfectly\n/// TODO rather than relying on TileServer a new lower level math library could be defined\n/// See - https://github.com/KhronosGroup/glTF/tree/master/extensions/1.0/Vendor/CESIUM_RTC ...\n///\n\nAFRAME.registerComponent('a-building', {\n  schema: {\n             lat: {type: 'number', default: 37.7983222 },\n             lon: {type: 'number', default: -122.3972797 },\n             lod: {type: 'number', default: 15},\n         stretch: {type: 'number', default: 1},\n          radius: {type: 'number', default: 6372798.2},\n    world_radius: {type: 'number', default: 6372798.2},\n             url: {type: 'string', default: \"https://assets.agi.com/stk-terrain/v1/tilesets/world/tiles\"}, // TODO remove\n         project: {type: 'number', default: 0 }, // TODO remove\n    building_url: {type: 'string', default: 'mozilla.cesium.com' },\n//    building_url: {type: 'string', default: 'https://s3.amazonaws.com/cesium-dev/Mozilla/SanFranciscoGltf15Gz1' },\n    //building_url: {type: 'string', default: 'https://s3.amazonaws.com/cesium-dev/Mozilla/SanFranciscoGltf15Gz' }, // older format\n  building_flags: {type: 'number', default: 2 } ,\n buildingTexture: {type: 'string', default: '' },\n   groundTexture: {type: 'string', default: '' },\n  },\n  init: function () {\n    let GLTFLoader = new AFRAME.THREE.GLTFLoader();\n    let data = this.data;\n    let scheme = _TileServer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].instance().scheme_elaborate(data);\n\n    let url = data.building_url+\"/\"+scheme.lod+\"/\"+scheme.xtile+\"/\"+scheme.ytile+\".gltf\";\n\n    GLTFLoader.load(url,(gltf) => {\n\n      // put lipstick on\n      this.gussy(gltf.scene);\n\n      // compute scale if geometric radius differs from planet radius\n      let s = data.world_radius ? data.radius/data.world_radius : 1;\n\n      // apply scale\n      this.el.object3D.scale.set(s,s,s);\n\n      if(data.building_flags & 2) {\n        // Buildings arrive rotated in 3d space as if they were being plunked onto the planet as is - also for a different cartesian XYZ axis\n        // I prefer to remove that rotation so that they're facing outwards from longitude 0 latitude 0\n        // (I suppose there's an ordered euler transform helper that could do this instead TODO)\n        // first de-rotate by longitude - bringing the object to the GMT\n        let q = new THREE.Quaternion();\n        q.setFromAxisAngle( new THREE.Vector3(0,1,0), THREE.Math.degToRad(-data.lon) - Math.PI/2 );\n        this.el.object3D.quaternion.premultiply(q);\n\n        // then de-rotate by latitude\n        q.setFromAxisAngle( new THREE.Vector3(1,0,0), THREE.Math.degToRad(data.lat) );\n        this.el.object3D.quaternion.premultiply(q);\n      }\n\n      // add to mesh to entity\n      this.el.setObject3D('mesh',gltf.scene);\n      gltf.scene.kind = \"building\"; // need some way to discriminate between kinds\n    });\n  },\n\n  gussy: function(group) {\n\n    if(!this.data.buildingTexture || this.data.buildingTexture.length < 1) return;\n    let texture = new THREE.TextureLoader().load('../env/'+this.data.buildingTexture);\n    let material = new THREE.MeshBasicMaterial({map:texture,color:0xffffff});\n\n    group.traverse( (child) => {\n\n      if (!(child instanceof THREE.Mesh)) {\n        return;\n      }\n\n      child.geometry = new THREE.Geometry().fromBufferGeometry( child.geometry );\n\n      let geometry = child.geometry;\n\n      geometry.computeBoundingBox();\n\n      var max = geometry.boundingBox.max,\n          min = geometry.boundingBox.min;\n      var offset = new THREE.Vector2(0 - min.x, 0 - min.y);\n      var range = new THREE.Vector2(max.x - min.x, max.y - min.y);\n      var faces = geometry.faces;\n\n      geometry.faceVertexUvs[0] = [];\n\n      if(!faces) return;\n\n      for (var i = 0; i < faces.length ; i++) {\n\n          var v1 = geometry.vertices[faces[i].a], \n              v2 = geometry.vertices[faces[i].b], \n              v3 = geometry.vertices[faces[i].c];\n\n          geometry.faceVertexUvs[0].push([\n              new THREE.Vector2((v1.x + offset.x)/range.x ,(v1.y + offset.y)/range.y),\n              new THREE.Vector2((v2.x + offset.x)/range.x ,(v2.y + offset.y)/range.y),\n              new THREE.Vector2((v3.x + offset.x)/range.x ,(v3.y + offset.y)/range.y)\n          ]);\n      }\n      geometry.computeVertexNormals();\n      geometry.computeFaceNormals();\n      geometry.computeBoundingBox();\n      geometry.computeBoundingSphere();\n      geometry.uvsNeedUpdate = true;\n\n      child.material = material;\n    });\n\n  }\n\n});\n\n\n\n//# sourceURL=webpack:///./src/a-building.js?");

/***/ }),

/***/ "./src/a-location.js":
/*!***************************!*\
  !*** ./src/a-location.js ***!
  \***************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _TileServer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TileServer.js */ \"./src/TileServer.js\");\n\nif (typeof AFRAME === 'undefined') {\n  throw new Error('Component attempted to register before AFRAME was available.');\n}\n\n\n\n///\n/// A-location\n/// If this is inside an a-terrain then the child will be on the surface at the specified latitude and longitude\n///\n/// TODO tileserver.scheme_elaborate could be moved to a lower level math module that everybody uses\n/// TODO would be nice to adjust size so it is always visible based on observer eyeball size\n///\n\nAFRAME.registerComponent('a-location', {\n  schema: {\n       lat: {type: 'number', default:  0},\n       lon: {type: 'number', default:  0},\n       latitude: {type: 'number', default:  0},\n       longitude: {type: 'number', default:  0},\n    elevation:        {type: 'number', default: 0         },\n    stretch:          {type: 'number', default: 1           },\n    radius: {type: 'number', default:  6372798.2},\n    world_radius: {type: 'number', default:  6372798.2},\n    lod:              {type: 'number', default: 15          },\n    url:              {type: 'string', default: \"https://assets.agi.com/stk-terrain/v1/tilesets/world/tiles\"},\n    mode: { type: 'string', default: 'absolute'}\n  },\n  init: function() {\n\n    // hack - support latitude and longitude as a back patch to work around naming changes\n    if(!this.data.lat) this.data.lat = this.data.latitude;\n    if(!this.data.lon) this.data.lon = this.data.longitude;\n\n    let scheme = _TileServer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].instance().scheme_elaborate(this.data);\n    let v = _TileServer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].instance().ll2v(scheme.latrad,scheme.lonrad,this.data.radius);\n    // TODO this approach is inelegant; it would be cleaner to apply the latitude and longitude rotations as done with rotating the world\n    this.el.object3D.position.set(v.x,v.y,v.z);\n    this.el.object3D.lookAt( new THREE.Vector3(0,0,0) );\n\n    // another hack - force objects above ground - unfortunately this pulls in a lot of aterrain baggage for now\n    if(this.data.mode != \"absolute\") {\n      let data = this.data;\n      _TileServer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].instance().ready(this.data.url,() => {\n        _TileServer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].instance().getGround(data.lat,data.lon,data.lod,data.url, groundValue => {\n          // deal with undefined\n          if(!groundValue) groundValue = 0;\n          // make sure is above ground\n          let e = groundValue + data.elevation;\n          // convert elevation above sea level to to model scale\n          let height = data.radius * e * data.stretch / data.world_radius + data.radius;\n          console.log(\"height=\"+height+\" radius=\"+data.radius);\n\n          let scheme = _TileServer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].instance().scheme_elaborate(this.data);\n          let v = _TileServer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].instance().ll2v(scheme.latrad,scheme.lonrad,height);\n          // TODO this approach is inelegant; it would be cleaner to apply the latitude and longitude rotations as done with rotating the world\n          this.el.object3D.position.set(v.x,v.y,v.z);\n          this.el.object3D.lookAt( new THREE.Vector3(0,0,0) );\n\n\n        });\n\n      });\n    }\n\n    // This would be cleaner - would avoid the lookat which is clumsy\n    //obj.rotation.set(0,0,0);\n    //var q = new THREE.Quaternion();\n    //q.setFromAxisAngle( new THREE.Vector3(0,1,0), THREE.Math.degToRad(-data.lon) );\n    // obj.quaternion.premultiply(q);\n    //q.setFromAxisAngle( new THREE.Vector3(1,0,0), THREE.Math.degToRad(data.lat) );\n    // obj.quaternion.premultiply(q);\n  },\n});\n\n\n\n//# sourceURL=webpack:///./src/a-location.js?");

/***/ }),

/***/ "./src/a-terrain.js":
/*!**************************!*\
  !*** ./src/a-terrain.js ***!
  \**************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _TileServer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TileServer.js */ \"./src/TileServer.js\");\n\nif (typeof AFRAME === 'undefined') {\n  throw new Error('Component attempted to register before AFRAME was available.');\n}\n\n// TODO there's no real reason why a-terrain should know about the tileserver - a-tile.js could have a system to return a collection of tiles on demand\n\n\n///\n/// a-terrain\n///\n/// manufactures a-tile instances to cover an area of observed space as a sphere\n///\n\nAFRAME.registerComponent('a-terrain', {\n\n  schema: {\n    // World radius is the physical size of the planet in question. The current default is Earth with a radius of 63727982 meters.\n    // TODO Earth is an oblate spheriod but I'm ignoring that fact... it could be improved.\n    world_radius:     {type: 'number', default: 6372798.2    },\n    // Radius is the geometric half width or height (or distance from surface to the center) of entire planet in a-frame.\n    // A user can use any radius and the planet will render correctly but at a radius == world_radius then the world is 1:1 with human scale walking and a-frame default camera setup\n    radius:           {type: 'number', default: 6372798.2    },\n    // Observer\n    // An observer may be null or may be a camera or other aframe 3d object with a position in 3d space that this component should watch\n    // If an observer exists then the { latitude, longitude, elevation, lod } will be manufactured dynamically every frame.\n    // If an observer does not exist or is invalid then the globe will use the supplied latitude, longitude and elevation to paint tiles\n    // TODO note this is not considering the observers field of view yet and since tiles are logarithmic and movement is linear it requires some thought when using\n    observer:         {type: 'string', default: \"\"          },\n    // follow mode (bit set)\n    //   1 = move globe such that the current latitude, longitude are at 0,0,0 (only if the observer is null)\n    //   2 = move globe elevation also (only if the observer is null)\n    follow:           {type: 'number', default: 3           },\n    // Current latitude, longitude and elevation in meters - currently 600 meters above Cafe Coquetta on the Embarcadero next to the bay in San Francisco\n    // Note elevation is NOT related to the rendering radius but is a planetary space value and should stay the same regardless of rendering radius\n    // Note that this exact position and elevation is where we have 3d building tiles and it's a good vantage point to showcase the data set\n    // Note if the observer is set then these below values are ignored and they are dynamically manufactured by looking at observers relative position\n    latitude:         {type: 'number', default: 37.7983222  },\n    longitude:        {type: 'number', default: -122.3972797},\n    elevation:        {type: 'number', default: 600         },\n    // How much to stretch planet heights by so that mountains are more visible\n    // TODO not fully implemented\n    stretch:          {type: 'number', default: 1           },\n    // LOD = Level of detail. If not specified then it will be computed from elevation.\n    lod:              {type: 'number', default: -1          },\n    input:            {type: 'number', default: 0           },\n    // fovpad is a hack to circumvent limits with observer field of view; basically a camera could be near the planet but see the whole planet at once\n    // TODO the tilings strategy should be improved to deal with some of the possible cases of observer field of view - remove this fudge factor later\n    fovpad:           {type: 'number', default: 0           },\n    debug:            {type: 'number', default: 0           },\n    url:              {type: 'string', default: \"https://assets.agi.com/stk-terrain/v1/tilesets/world/tiles\"},\n    building_url:     {type: 'string', default: 'https://s3.amazonaws.com/cesium-dev/Mozilla/SanFranciscoGltf15Gz1'  },\n    building_flags:   {type: 'number', default: 2           },\n    buildingTexture:  {type: 'string', default: '' },\n    groundTexture:    {type: 'string', default: '' },\n  },\n\n  ///\n  /// No need for more than one copy of component\n  /// \n  multiple: false,\n\n  // Internal list of tiles for sweeper convenience\n  tiles: {},\n\n  // Latch for startup - TODO probably a more elegant way to latch tick() after init callback is done\n  refreshState: 0,\n\n/*\n  inputControls: function() {\n    if(!this.data.input)\n      return;\n\n    // this is an optional control to move the planet under the observer - constantly generating new tiles\n\n    document.addEventListener('keydown', (event) => {\n      switch(event.keyCode) {\n        case 81: this.data.elevation = this.data.elevation * 1.5; break;\n        case 69: this.data.elevation = this.data.elevation / 1.5; break;\n        case 38: case 87: this.data.latitude += this.data.elevation / 10000; break;\n        case 40: case 83: this.data.latitude -= this.data.elevation / 10000; break;\n        case 39: case 68: this.data.longitude += this.data.elevation / 10000; break;\n        case 37: case 65: this.data.longitude -= this.data.elevation / 10000; break;\n      }\n    });\n  },\n\n  init: function() {\n    this.inputControls();\n  },\n*/\n\n  init: function() {\n\n    // refine soon - TODO\n    Cesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiI4YzI5OGVlNy1jOWY2LTRjNmEtYWYzMC1iNzhkZDhkZmEwOWEiLCJpZCI6MTM2MCwiaWF0IjoxNTI4MTQ0MDMyfQ.itVtUPeeXb7dasKXTUYZ6r3Hbm7OVUoA26ahLaVyj5I';\n\n    _TileServer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].instance().ready(this.data.url,function() {\n      console.log(\"Lower level TileServer is ready\");\n    });\n  },\n\n  ///\n  /// tick at 60fps\n  ///\n  tick: function() {\n    if(!_TileServer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].instance().isReady()) {\n      return;\n    }\n    // Update level of detail based on viewing mode\n    this.updateView();\n    // Sweep old tiles if any\n    this.sweepTiles();\n  },\n\n  ///\n  /// Update view based on view mode\n  ///\n  updateView: function() {\n\n    let data = this.data;\n\n    let observer = (data.observer && data.observer.length) > 0 ? this.el.sceneEl.querySelector(\"#\"+data.observer) : 0;\n\n    if(observer) {\n\n      // Throw away supplied position and elevation and compute relative to observer\n\n      // get world positions of both the globe and the observer\n      let v1 = this.el.object3D.getWorldPosition();\n      let v2 = observer.object3D.getWorldPosition();\n\n      // get distance between them...\n      let d = v1.distanceTo(v2);\n\n      // find relative vector of unit length pointing at the observer\n      let m = new THREE.Matrix4();\n      m.getInverse( this.el.object3D.matrixWorld );\n      v2.transformDirection(m);\n\n      let lat = Math.asin(v2.y);\n      let lon = Math.atan2(v2.x,v2.z);\n  \n      // Exit now if no significant change\n      if(this.previous_distance == d && this.previous_lat == lat && this.previous_lon == lon) {\n        return;\n      }\n      this.previous_distance = d;\n      this.previous_lat = lat;\n      this.previous_lon = lon;\n\n      // go to degrees (for user convenience - this is a bit messy tidy up later)\n      data.latitude = lat * 180.0 / Math.PI;\n      data.longitude = lon * 180.0 / Math.PI;\n\n      // find planetary coordinate space distance from sealevel of ellipsoid (or a sphere as is the case in this engine)\n      data.elevation = d * data.world_radius / data.radius - data.world_radius;\n\n      // What is a pleasant level of detail for a given distance from the planets center in planetary coordinates?\n      // TODO it is arguable that this could be specified separately from elevation rather than being inferred\n      if(data.lod < 0 || data.lodLatch == 1) {\n        data.lodLatch = 1;\n        data.lod = _TileServer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].instance().elevation2lod(data.world_radius,data.elevation);\n      }\n    }\n\n    else {\n\n      // this is a slight hack to allow a caller to specify lat lon - it's not formally documented as a feature\n\n      var hash = window.location.hash.substring(1);\n      var params = {}\n      hash.split('&').map(hk => { let temp = hk.split('='); params[temp[0]] = temp[1]; });\n      if(params.lat) { data.latitude = parseFloat(params.lat); data.longitude = parseFloat(params.lon); }\n      if(params.elev) {\n        data.elevation = parseFloat(params.elev);\n      }\n      if(params.lod) {\n        data.lod = parseInt(params.lod);\n      }\n\n      // Focus on user supplied latitude longitude and elevation\n\n      // Exit now if no significant change\n      if(this.previous_elevation == data.elevation && this.previous_lat == data.latitude && this.previous_lon == data.longitude) {\n        return;\n      }\n      this.previous_elevation = data.elevation;\n      this.previous_lat = data.latitude;\n      this.previous_lon = data.longitude;\n\n      if(data.follow & 1) {\n        // rotate planet so that the salient interest area is pointing north - ie on a vector of 0,1,0\n        this.el.object3D.rotation.set(0,0,0);\n        var q = new THREE.Quaternion();\n        q.setFromAxisAngle( new THREE.Vector3(0,1,0), THREE.Math.degToRad(-data.longitude) );\n        this.el.object3D.quaternion.premultiply(q);\n        q.setFromAxisAngle( new THREE.Vector3(1,0,0), THREE.Math.degToRad(-(90-data.latitude) ) );\n        //q.setFromAxisAngle( new THREE.Vector3(1,0,0), THREE.Math.degToRad(data.lat) ); // <- if you wanted lat,lon just facing you if you were at 0,0,1\n        this.el.object3D.quaternion.premultiply(q);\n      }\n\n      if(data.follow & 2) {\n        // translate planet surface to 0,0,0 in model coordinates\n        let height = data.radius * data.elevation * data.stretch / data.world_radius + data.radius;\n        this.el.object3D.position.set(0,-height,0);\n      }\n\n      // What is a pleasant level of detail for a given distance from the planets center in planetary coordinates?\n      // TODO it is arguable that this could be specified separately from elevation rather than being inferred\n      if(data.lod < 0 || data.lodLatch == 1) {\n        data.lodLatch = 1;\n        data.lod = _TileServer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].instance().elevation2lod(data.world_radius,data.elevation);\n      }\n\n      _TileServer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].instance().getGround(data.latitude,data.longitude,data.lod,data.url, groundValue => {\n        // deal with undefined\n        if(!groundValue) groundValue = 0;\n        // make sure is above ground\n        let e = groundValue + data.elevation;\n        // convert elevation above sea level to to model scale\n        let height = data.radius * e * data.stretch / data.world_radius + data.radius;\n        console.log(\"Dynamically moving planet to adjust for ground=\" + groundValue + \" height=\"+height + \" stretch=\"+data.stretch + \" elev=\"+e);\n        this.el.object3D.position.set(0,-height,0);\n      });\n\n    }\n\n    // Copy user values to internal - TODO remove this by code cleanup later - naming inconsistencies\n    data.lat = data.latitude;\n    data.lon = data.longitude;\n\n    // TODO these limits are imposed by the current data sources - and should not be true for all data sources\n    if(data.lat > 85) data.lat = 85;\n    if(data.lat < -85) data.lat = -85;\n\n    // ask tile server for facts about a given latitude, longitude, lod\n    let scheme = _TileServer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].instance().scheme_elaborate(data);\n\n    // the number of tiles to fetch in each direction is a function of the camera fov (45') and elevation over the size of a tile at current lod\n    let count = Math.floor(data.elevation / scheme.width_tile_lat) + 1;\n\n    // render the field of view - TODO this strategy is not comprehensive - the camera can see past the visible tiles depending on FOV and if not looking down.\n    let fovpad = data.fovpad;\n    for(let i = -count-fovpad;i<count+1+fovpad;i++) {\n      for(let j = -count-fovpad;j<count+1+fovpad;j++) {\n        // TODO this is sloppy; there is a chance of a numerical error - it would be better to be able to ask for tiles by index as well as by lat/lon\n        let scratch = { lat:data.lat + scheme.degrees_lat * i,\n                        lon:data.lon + scheme.degrees_lon * j,\n                        lod:data.lod,\n                    stretch:data.stretch,\n                     radius:data.radius,\n               world_radius:data.world_radius,\n                        url:data.url,\n               building_url:data.building_url,\n               building_flags:data.building_flags,\n               buildingTexture:data.buildingTexture,\n               groundTexture:data.groundTexture,\n                    project:1,\n                      };\n        // hack terrible code TODO cough forever loop\n        while(scratch.lon < -180) scratch.lon += 360;\n        while(scratch.lon >= 180) scratch.lon -= 360;\n        while(scratch.lat < -90) scratch.lat += 180;\n        while(scratch.lat >= 90) scratch.lat -= 180;\n        this.updateOrCreateTile(scratch);\n      }\n    }\n\n  },\n\n  ///\n  /// Satisfy that a given tile exists from supplied lat,lon,elevation\n  ///\n  updateOrCreateTile: function(data) {\n    let scheme = _TileServer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].instance().scheme_elaborate(data);\n    let element = this.tiles[scheme.uuid];\n    if(element) {\n      element.setAttribute(\"visible\",true);\n    } else {\n      // if not found then ask a tile to build itself in such a way that it covers the given latitude, longitude, lod\n      element = document.createElement('a-entity');\n      element.setAttribute('id',scheme.uuid);\n      element.setAttribute('a-tile',data);\n      this.el.appendChild(element);\n      // WARN set lod and loaded directly on the element right now because getAttribute() appears to sometimes not be set synchronously\n      element.lod = data.lod;\n      element.loaded = 0;\n      this.tiles[scheme.uuid] = element;\n    }\n  },\n\n  ///\n  /// Hide any tiles that are not at the current LOD if current LOD is fully present\n  ///\n  sweepTiles: function() {\n\n    let lod = this.data.lod;\n\n    // bail immediately and do not sweep if any tiles at the current lod are not ready\n    let keys = Object.keys(this.tiles);\n    for(let i = 0; i < keys.length; i++) {\n      let element = this.tiles[keys[i]];\n      if(element.lod == lod && element.loaded != 1) {\n        let properties = element.getAttribute('a-tile');\n        return;\n      }\n    };\n\n    // sweep other tiles that are not at current lod\n    for(let i = 0; i < keys.length; i++) {\n      let element = this.tiles[keys[i]];\n      if(element.lod != lod && element.getAttribute(\"visible\") != false) {\n        element.setAttribute(\"visible\",false); \n      }\n    };\n\n  },\n\n});\n\n\n\n//# sourceURL=webpack:///./src/a-terrain.js?");

/***/ }),

/***/ "./src/a-tile.js":
/*!***********************!*\
  !*** ./src/a-tile.js ***!
  \***********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _TileServer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TileServer.js */ \"./src/TileServer.js\");\n\nif (typeof AFRAME === 'undefined') {\n  throw new Error('Component attempted to register before AFRAME was available.');\n}\n\n\n\n///\n/// a-tile\n/// A single tile as specified by the tileServer abstraction\n///\n\nAFRAME.registerComponent('a-tile', {\n  schema: {\n             lat: {type: 'number', default: 37.7983222 },\n             lon: {type: 'number', default: -122.3972797 },\n             lod: {type: 'number', default: 15},\n         stretch: {type: 'number', default: 1},\n          radius: {type: 'number', default: 6372798.2},\n    world_radius: {type: 'number', default: 6372798.2},\n             url: {type: 'string', default: \"https://assets.agi.com/stk-terrain/v1/tilesets/world/tiles\"},\n          // TODO study -> there seem to be more missing tiles here - don't use this source for now?\n          // url: {type: 'string', default: 'https://beta.cesium.com/api/assets/3699?access_token=' + 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiJlYmI0ZmY0My1hOTg5LTQzNWEtYWRjNy1kYzYzNTM5ZjYyZDciLCJpZCI6NjksImFzc2V0cyI6WzM3MDQsMzcwMywzNjk5LDM2OTNdLCJpYXQiOjE1MTY4MzA4ODZ9.kM-JnlG-00e7S_9fqS_QpXYTg7y5-cIEcZEgxKwRt5E' },\n         project: {type: 'number', default: 0 },\n    building_url: {type: 'string', default: 'https://s3.amazonaws.com/cesium-dev/Mozilla/SanFranciscoGltf15Gz1'  },\n  building_flags: {type: 'number', default: 2           },\n buildingTexture: {type: 'string', default: '' },\n   groundTexture: {type: 'string', default: '' },\n  },\n  init: function () {\n\n    let data = this.data;\n\n    _TileServer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].instance().produceTile(data,scheme => {\n\n      // show tile\n      this.el.setObject3D('mesh',scheme.mesh);\n      scheme.mesh.kind = \"tile\"; // need some way to discriminate between tiles and other things\n\n      if(data.project) {\n\n        // translate to surface of sphere\n        let offset = _TileServer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].instance().ll2v(scheme.rect.south, //+scheme.degrees_latrad/2,\n                                      scheme.rect.west, //+scheme.degrees_lonrad/2,\n                                      scheme.radius );\n        this.el.object3D.position.set(offset.x,offset.y,offset.z);\n\n        // rotate to correct latitude\n        let q = new THREE.Quaternion();\n        q.setFromAxisAngle( new THREE.Vector3(1,0,0), -scheme.rect.south); //-scheme.degrees_latrad/2 );\n        this.el.object3D.quaternion.premultiply(q);\n\n        // rotate to correct longitude\n        q.setFromAxisAngle( new THREE.Vector3(0,1,0), scheme.rect.west); //+scheme.degrees_lonrad/2 );\n        this.el.object3D.quaternion.premultiply(q);\n\n\n      }\n\n      // mark as complete\n      this.el.loaded = 1;\n      // look for buildings\n      if(scheme.lod >= 15) {\n        // try fetch a building - unfortunately this throws an error and there's no way to not log it if the building is not found\n        let building = document.createElement('a-entity');\n        building.setAttribute('a-building',data);\n        this.el.appendChild(building);\n      }\n\n    });\n  }\n});\n\n\n\n//# sourceURL=webpack:///./src/a-tile.js?");

/***/ }),

/***/ "./src/all.js":
/*!********************!*\
  !*** ./src/all.js ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("__webpack_require__(/*! ./a-location.js */ \"./src/a-location.js\");\n__webpack_require__(/*! ./a-building.js */ \"./src/a-building.js\");\n__webpack_require__(/*! ./a-tile.js */ \"./src/a-tile.js\");\n__webpack_require__(/*! ./a-terrain.js */ \"./src/a-terrain.js\");\n\n\n//# sourceURL=webpack:///./src/all.js?");

/***/ })

/******/ });